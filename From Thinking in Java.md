内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。
内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，使用OuterClassName.InnerClassName来指明这个对象的类型。
当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。
内部类可以访问其外围类的方法和字段，就像自己拥有它们似的，这带来了很大的方便。
所以内部类自动拥有对其外围类所有成员的访问权。
当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。
接口的所有成员自动被设置为public的。
如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用时final的。
在匿名类中不可能有命名构造器，但通过实例初始化，就能达到匿名内部类创建一个构造器的效果。
闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象的信息，还自动拥有一个指向此外围类的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。
设计模式总是将变化的事物与保持不变的事物分离开。

Collection：
	一个独立元素的序列，这些元素都服从一条或多条规则。List必须按照插入的顺序保持元素，而Set不能有重复元素。Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。
Map：
	一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许使用数字来查找值，因此来某种意义上讲，它将数字与对象关联在一起。映射表允许我们使用另一个对象来查找某个对象，它也被称为“关联数组”，因为它将某些对象与另外一个对象关联在一起；或者被称为“字典”，因为它可以使用键对象来查找值对象，就像在字典中使用单词来定义一样。
    
Collection在每个槽中只能保存一个元素。此类容器包括：
	List，它以特定的顺序保存一组元素。
	Set，元素不能重复。
	Queue，只允许在容器的一端插入对象，并从另外一端移除对象。
	Map，在每个槽内保存了两个对象，即键和与之关联的值。

List：
	基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。
	LinkedList，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢，但是它的特性集较ArrayList更大。
Set：不保存重复的元素。Set中最常被使用的是测试归属性，可以很容易地询问某个对象是否在某个Set中，正因如此，查找就成为了Set中最重要的操作，因此通畅都会选择一个HashSet实现，它专门对快速查找进行了优化。Set是基于对象的值来确定归属性。

TreeSet将元素存储在红－黑树数据结构中，而HashSet使用的是散列函数。LinkedHashList因为查询速度的原因也使用了散列，但是看起来它使用了链表来维护元素的插入顺序。

Collection是描述所有序列容器的共性的跟接口，它可能会被认为是一个“附属接口”，即因为要表示其他若干个接口的共性而出现的接口。另外，java.util.AbstractCollection类提供了Collection的默认实现，使得你可以创建AbstractCollection的子类型，而其中没有不必要的代码重复。

使用接口描述的一个理由是它可以使我们能够创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多的对象类型。

如果实现Collection，就必须实现iterator()，并且只拿实现的iterator()与继承AbstractCollection相比，花费的代价只有略微减少。

Java提供了大量持有对象的方法：
1.数组将数字与对象关联起来。它保存类型明确的对象，查询对象时，不需要对结果做类型转换。它可以是多维的，可以保存基本类型数据。但是数组一旦生成，其容量就不能改变。
2.Collection保存单一的元素，而Map保存相关联的键值对。有了Java的泛型，就可以指定容器中存放的对象类型，因此就不会将错误类型的对象放置到容器中，并且在从容器中获取元素时，不必进行类型转换。各种Collection和各种Map都可以在你向其中添加更多的元素时，自动调整其尺寸。容器不能持有基本数据类型，但是自动包装机制会仔细地执行基本类型到容器中所持有的包装器类型之间的双向转换。
3.像数组一样，List也建立数字索引与对象的关联，因此，数组和List都是排好序的容器。List能够自动扩充容器。
4.如果要进行大量的随机访问，就使用ArrayList；如果要经常从表中间插入或删除元素，则应该使用LinkedList。
5.各种Queue以及栈的行为，由LinkedList提供支持。
6.Map是一种将对象（非数字）与对象相关联的设计。HashMap设计用来快速访问；而TreeMap保持“键”始终处于排序状态，所以没有HashMap快。LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问能力。
7.Set不接受重复元素。HashSet提供最快的查询速度，而TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保存元素。
8.新程序中不应该使用过时的Vector、Hashtable和Stack。

