#影响Java调用性能的因素
###内联

```java
    class Foo {
        void bar() {...}
    }
```

```java
    Foo foo = new Foo();
    foo.bar();
```

`foo.bar()`称为调用点。当我们说一个方法“被内联”，意指方法体被插入到了调用点的位置上，以代替方法调用。对于那些由许多短小的方法所构成的程序————称之为被适当分解的程序————内联可以有效地提升性能。这是因为结束以后可以发现，程序并没有把所有时间用在方法的调用上，实际上程序并没有工作！

###多态性

默认情况下，方法将在Java中被虚拟化（可重写）。对于任一调用点，编译器需要在一个称为虚拟表（vtable）的表中寻找与其对应的方法。这是个非常耗时的过程，所以，能进行优化的编译器，总是会试图减少这种查询带来的开销。一种方法就是内联，这的确是个良策，但前提是编译器能证明在给定的调用点上调用的方法唯一。这样的调用点称之为单态调用点。
不幸的是，进行这种分析需要耗费大量时间。所以在实际过程中，确定一个调用点是否单态是个不太可取的方法。对此，JIT编译器倾向于使用一种替代方法：列出哪些类可以在此调用点被调用，接着根据之前的N个相同的调用猜测此调用点是否是单态的。以假定某个调用点永远为单态，来进行投机性质的优化往往是可取的行为。因为这样的优化往往都是正确的，但也因它无法确保永远正确，编译器需要在方法调用之前注入一个用于检查方法类型的防护机制。
除了单态的调用点以外。一种称为双态调用点，在该点上有两个候选方法。对此你依然可以实现内联————借助防护代码，让其检测应调用哪一个方法，并引导程序跳转至内联在调用点的两个方法体中真正对应的那一个。

可以断定的是，仅添加一个final关键字并不会大幅度提升调用性能，重写一个方法也不见得会带来什么影响。换句话说，final关键字不会产生性能上的影响。

###结论

+   最快与最短的方法调用的类型之间存在巨大的性能差别。
+   在实际应用中，添加或删除final关键字并不会真正影响性能。但如果除此以外，你还在层级结构上进行某些操作，那这些行为则可能导致性能下降。
+   更深的类的层次结构并不会真正影响到调用的性能。
+   单态调用比双态调用更快。
+   双态调用比超多态调用更快。
+   我们在能够进行剖析（profile-ably），但是不能进行查验的单态调用点中看到类型保护，这种保护会使得这些调用点的调用性能低于那些能够进行查验的单态调用点。
+   如果方法太长，那么它将不会被内联，为此你必须承受方法调用带来的开销。另外，为了使代码具有易读性，应当把方法写的短小。

From www.importnew.com
