#Something About NodeJS

###服务端JavaScript

JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有说太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门完整的语言：它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。

Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。

要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。

Node.js事实上即时一个运行时环境，同时又是一个库。

在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。

###基于事件驱动的回调

当我们使用`http.createServer`方法时，当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。

问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。

写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。那么在Node.js程序中，当一个新的请求到达8888端口的时候，怎样控制流程呢？

这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙了。

我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数的就会被调用。我们不知道这件事什么时候回发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。

这就是传说中的回调：我们给某个方法传递了一个函数，这个方法在有相应时间发生时，调用这个函数来进行回调。

favicon.ico: 便是其可以让浏览器的收藏夹中除显示相应的标题外，还以图标的方式区别不同的网站。除了收藏夹中的图标外，还会出现在地址栏中。FireFox支持动画格式的favicon。

###如果来进行请求的“路由”

我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。

因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器缺失值得探讨，但这里暂定其为我们的HTTP服务器的功能。

我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，分别为url和querystring模块。

```javascript
                                   url.parse(string).query
                                               |
               url.parse(string).pathname      |
                           |                   |
                           |                   |
                         ------ -------------------
    http://localhost:8888/start?foo=bar&hello=world
                                    ---       -----
                                     |          |
                                     |          |
                  querystring(string)["foo"]    |
                                                |
                             querystring(string)["hello"]
```

当然我们也可以用querystring模块来解析POST请求体中的参数。

函数式编程是指将函数作为参数传递。

想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。类似于，“嗨！那个叫路由的东西，能帮我把这个路由一下吗？”

但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。

###路由给真正的请求处理程序

路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该喝处理/upload的不同。

我们暂时把作为路由目标的函数称为请求处理程序。现在我们不着急来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。

在C++或C#中，当我们谈到对象，指的是类活着结构体的实例。对象根据他们实例化的模版（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合————你可以把JavaScript的对象想象成一个键为字符串类型的字典。

但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字活着......函数！

###阻塞与非阻塞

Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理————Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点————尽肯能的避免阻塞操作，取而代之，多使用非阻塞操作。

然而，要使用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比如，休眠10秒，或者查询数据库，又或者是进行大量的计算）。

对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这 里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个 callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”

###以非阻塞操作进行请求响应



